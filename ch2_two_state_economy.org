#+TITLE: Chapter 2: Two-State Economy

The analysis of this chapter is based on the most simple model economy that is still rich enough to introduce many important notions and concepts of finance: an economy with two relevant points in time and two uncertain future states only. It also allows us to present some important results in the field, like the Fundamental Theorems of Asset Pricing.

| Finance                               | Mathematics                                  | Python                           |
|---------------------------------------+----------------------------------------------+----------------------------------|
| Time                                  | Natural Numbers N                            | int, type                        |
| Money (Currency)                      | Real Numbers R                               | float                            |
| Cash Flow                             | Tuple                                        | tuple, list                      |
| Return, Interest                      | Real Numbers R                               | abs                              |
| Net Present Value                     | Function                                     | def, return                      |
| Uncertainty                           | Vector Space R^2                             | np, ndarray, np.array            |
| Financial Asset                       | Process                                      | ndarray, tuple                   |
| Risk                                  | Probability, State Space, Power Set, Mapping | ndarray                          |
| Expectation, Expected Return          | dot product                                  | np.dot                           |
| Volatility                            | Variance, Standard Deviation                 | np.sqrt                          |
| Contingent Claims                     | Random Variable                              | np.arange, np.maximum, plt.plot  |
| Replication, Arbitrage                | Linear Equations, Matrix Form                | ndarray, np.linalg.solve, np.dot |
| Completeness, Arrow-Debreu Securities | Linear Independence, Span                    | np.linalg.solve                  |
| Martingale Pricing                    | Martingale, Martingale Measure               | np.dot                           |
| Mean-Variance                         | Expectation, Variance, Standard Deviation    | np.linspace, .std(), list comp   |

* Economy

An economy is an abstract notion that subsumes other elements of the financial model, like assets (real, financial), agents (people, institutions), or money.

** Real Assets

Multiple real assets are available in the economy that can be used for different purposes. It might be a machine or a cup

** Agents

Agents can be thought of as individual human beings being active in the economy. They accept money during transactions and spend it during others.

** Time

Economic activity takes place at discrete points in time only.

** Money

In the economy, money is available in unlimited supply. Money is also infinitely divisible. Money should be thought of in abstract terms only and not in terms of cash (physical coins or bills).

Money in general serves as the *numeraiare* in the economy, in that the value of one unit of money (like USD, EUR, GBP, etc) is normalized to exactly 1.

** Cash Flow

Combining time with currency leads to the notion of cash flow. An investment is generally considered to be a *cash outflow*, and one often represents this as a negative real number. The payback is a *cash inflow* and therewith a positive real number.

To indicate points in time when cash flows happen, a time index is used: $c_{t=0} = -9.5$, $c_{t=1}=11.75$

A pair of cash flows now and one year from now is modeled mathematically as an ordered pair or two-tuple which combines the two relevant cash flows into one object:

$c = (c_0, c_1)$

** Return

Consider an investment project with cash flows $c = (c_0, c_1) = (-10, 12)$.
The return $R \in \mathcal{R}$ of the project is the sum of the cash flows $c_0 + c_1 = -10 + 12 = 2$.
The rate of return $r \in \mathcal{R}$ is the return divided by the absolute value of the investment outlay $r = \frac{R}{|c_0|} = \frac{-10 + 12}{10} = 0.2$

#+begin_src python
c = (-10, 12)
R = sum(c)
R
r = R / abs(c[0])
r
#+end_src

** Interest

There is a difference between a cash flow today and a cash flow in one year. It results from interest that is being earned on currency units or that has to be paid to borrow currency units. Interest in this context is the price being paid for having control over money that belongs to another agent.

An agent that has currency units that they do not need today can deposit these with a bank or lend them to another agent to earn interest. If the agent needs more currency units than they currently have available, they can borrow them from a bank or other agents, but they will need to pay interest.

** Present Value

Having lending or depositing options available leads to opportunity costs for deployign money in an investment project.
To appropriately compare cash flows in one year with those of today, the present value needs to be calculated. This is accomplished by discounting using the fixed interest rate in the economy.

Discounting can be modeled as a function $D:\mathcal{R} \to \mathcal{R}$ which maps a real number (cash flow in one year) to another real number (cash flow today).

$c_0 = D(c_1) = \frac{c_1}{1 + i}$

#+begin_src python
from typing import Union

def discounted_cash_flow(cash_flow: Union[tuple, float], interest_rate: float) -> float:
    float_num = type(cash_flow) == float
    last_cash_flow = cash_flow if float_num else cash_flow[-1]
    num_years = 1 if float_num else len(cash_flow) - 1
    return last_cash_flow / ((1 + interest_rate) ** num_years)

discounted_cash_flow(12.1, 0.1)
discounted_cash_flow(11.0, 0.1)
discounted_cash_flow((1, 2, 3, 4, 5), 0.1)
#+end_src

** Net Present Value

How shall an agent decide whether to conduct an investment project or not? One criterion is the net present value.
The net present value, NPV $\in \mathcal{R}$, is the sum of the cash outflow today and the present value of the cash inflow in one year:

$NPV(c) = c_0 + D(c_1)$

If the net present value is positive, the project should be conducted. If negative, then not, since the alternative of just depositing the money with a bank is more attractive.

#+begin_src python
from typing import Tuple

cA = (-10.5, 12.1)
cB = (-10.5, 11.0)

def NPV(c: Tuple[float, float], interest_rate: float) -> float:
    return c[0] + discounted_cash_flow(c[-1], interest_rate)

NPV(cA, 0.1)
NPV(cB, 0.1)
#+end_src

** Uncertainty

Cash inflows from an investment project one year from now are in general uncertain. In the model economy, the concept of states of the economy in one year subsumes the influence of all relevant factors. Assume that in one year the economy might be in one of two different states $u$ and $d$, which might be interpreted as up and down. The cash flow of a project in one year then becomes a vector

$c_1 \in \mathbb{R}^2$ where $c_1 = (c_1^u, c_1^d)$

representing the relevant cash flows per state of the economy. Formally this is represented as a column vector

$c_1 = {c_1^u \choose c_1^d}$

#+begin_src python
import numpy as np

c0 = -10
c1 = np.array((20, 5))
c = (c0, c1)
#+end_src

** Financial Assets

Financial assets are financial instruments ("contracts") that have a fixed price today and an uncertain price in one year.
Such a share might be available at a price today of $S_0 \in \mathbb{R}_{>0}$. The price of the share in one year depends on the success of the investment project, i.e., whether a high cash inflow is observed in the u state or a low one in the d state. Formally, $S_1^u, S_1^d \in \mathbb{R}_{\geq 0}$ where $S_1^u > S_1^d$.

One speaks also of the price process of the financial asset $S:\mathbb{N}_0 \cross \{u, d\} \to \mathbb{R}_{\geq 0}$ mapping time and state of the economy to the price of the financial asset.

** Probability Measure

The probabilities for events that are physically possible together form a probability measure. Such a probability measure is a function $P:\mathcal{P}(\{u, d\}) \to \mathbb{R}_{\geq 0}$ mapping all elements of the power set of $\{u, d\}$ with $\mathcal{P}(\{u, d\})$ to the unit interval.
In this context, the set $\{u, d\}$ is called the state space and is symbolized by $\Omega$. The triple $(\Omega, \mathcal{P}(\Omega), P)$ is called a probability space.

A function P representing a probability measure needs to satisfy 3 conditions:

1. $P(\emptyset) = 0$
2. $0 \leq P(\omega), \omega \in \Omega \leq 1$
3. $P(\Omega) = P(u) + P(d) = 1$

Having a fully specified probability measure available, the model economy is typically called an economy under risk.
A model economy without a fully specified probability measure is often called an economy under ambiguity

Uncertainty in a financial context can take on different forms. Risk in general refers to a situation in which a full probability distribution over future states of the economy is assumed to be known. Ambiguity refers to situations in which such a distribution is not known.

#+begin_src python
p = 0.4
P = np.array((p, 1-p))
P
#+end_src

** Expectation

The expectation can be interpreted as the weighted average, where the weights are given by the probabilities.
The expectation of the uncertain price $S_1$ in one year under probability measure $P$ is

$\mathbb{E}^p(S_1) = \Sigma_{\omega \in \Omega} P(\omega) \cdot S_1^{\omega} = p \cdot S_1^u + (1 - p) \cdot S_1^d$

#+begin_src python
S0 = 10
S1 = np.array((20, 5))
np.dot(P, S1)
#+end_src

** Expected Return

Under uncertainty, the notions of return and rate of return need to be adjusted. In such a case, the expected return of a financial asset is given as the expectation of the price in one year minus the price today. This can be seen by taking the expectation of the uncertain return $R = (R^u, R^d)^T$ and rearranging as follows:

$\mathbb{E}^p(R) = ({p \choose 1 - p}, {R^u \choose R^d}) = ({p \choose 1 - p}, {S_1^u - S_0 \choose S_1^d - S_0}) = p \cdot (S_1^u - S_0) + (1 - p) \cdot (S_1^d - S_0) = \mathbb{E}^p(S_1) - S_0$

The expected rate of return is the expected return divided by the price today

$\mathbb{E}^P(r) = \frac{\mathbb{E}^P(R)}{S_0}$

#+begin_src python
def expected_return(initial_price: float, probabilities: np.array, upside_downside: np.array) -> float:
    return np.dot(probabilities, upside_downside) - initial_price


def expected_rate_of_return(initial_price: float, expected_return: float) -> float:
    return expected_return / initial_price


S0 = 10
p = 0.4
P = np.array((p, 1 - p))
S1 = np.array((20, 5))
er = expected_return(S0, P, S1)
err = expected_rate_of_return(S0, er)
er
err
#+end_src

** Volatility

In finance, risk and expected return are the dominating pair of concepts. Risk can be measured in many ways, while the volatility as measured by the standard deviation of the rates of return is probability the most common measure.

In this context, the variance of the return rates of a financial aspect is defined by

$\sigma^2(r) = \mathbb{E}^p((r - \mu)^2) = ({p \choose 1 - p}, {(r^u - \mu)^2 \choose (r^d - \mu)^2})$

where $\mu$ is the expected rate of return, and $r^\omega \equiv (S_1^\omega - S_0) / S_0, \omega \in \Omega$.

The volatility is defined as the standard deviation of the return rates, which is the square root of the variance

$\sigma(r) = \sqrt{\sigma^2(r)}$

#+begin_src python
def rate_of_return(x0: np.array, x1: np.array) -> float:
    return (x1 - x0) / x0

rate_of_return(S0, S1)

mu = np.dot(P, rate_of_return(S0, S1))
mu

def sigma_squared(probability_measure: np.array, rate_of_return: float, expected_rate_of_return: float) -> float:
    return np.dot(probability_measure, (rate_of_return - expected_rate_of_return) ** 2)

ss = sigma_squared(P, rate_of_return(S0, S1), mu)
ss

sigma = np.sqrt(ss)
sigma
#+end_src

** Contingent Claims

A *contingent claim* is a financial asset - formalized by some contract - that offers a state-contingent payoff one year from now.
Such a contingent claim can have an arbitrary state-contingent payoff or one that is derived from the payoff of other financial assets.

In the latter case, one generally speaks of *derivative assets* or *derivative instruments*

Formally, a contingent claim is a function $C_1: \Omega \to \mathbb{R}_{\geq 0}, \omega \to C_1(\omega)$, mapping events to non-negative real numbers.

Suppose we have a risky stock with the price process

$S = (S_0, (S_1^u, S_1^d)^T)$

A *call option* on the stock has a payoff in one year of $C_1(S_1(\omega)) = \max(S_1(\omega) - K, 0)$ and $\omega \in \Omega$. $K \in \mathbb{R}^+$ is called the strike price option.

#+begin_src python
# visualize the payoff of a call option on a segment of the real line
S1 = np.random.normal(10, 2.5, 20)
K = 10

C1 = np.maximum(S1 - K, 0)

from pylab import mpl, plt
import matplotlib
matplotlib.use('tkAgg')
plt.style.use('seaborn')
mpl.rcParams['savefig.dpi'] = 300
mpl.rcParams['font.family'] = 'serif'

plt.figure(figsize=(10, 6))
plt.plot(np.arange(20), C1, lw=3.0, label='$C_1 = \max(S_1 - K, 0)$')
plt.legend(loc=0)
plt.xlabel('$S_1$')
plt.ylabel('$C_1$')
plt.show()
#+end_src

** Replication

When introducing a contingent claim into the economy, an important question that arises is whether the payoff of the contingent claim is redundant or not.

The payoff of the call option is said to be linearly dependent - or redundant - when a solution to the following problem exists:

$b \cdot {B_1 \choose B_1} + s \cdot {S_1^u \choose S_1^d} = {C_1^u \choose C_1^d}$

Essentially, if we have a linearly dependent system like above, we can buy/sell some amount of the bond / stock to replicate the payoff of the call option.

Technically, *short selling* implies borrowing the respective number of units of the financial asset today from another agent and immediately selling the units in the market. In one year, the borrowing agent buys the exact number of units of the financial asset back in the market at the then-current price and transfers them back to the other agent.

$\mathcal{M} =  \begin{pmatrix} B_1 & S_1^u\\ B_1 & S_1^d \end{pmatrix}$

The future payoff vectors of the bond and the stock represent the values in the first and second column of the matrix, respectively.

With these conventions, the replication problem can be represented in matrix form as

$\mathcal{M} \cdot \phi = C_1$

where $\phi \in \mathbb{R}^2$ is the vector containing the bond and stock portfolio positions for replication $\phi \equiv (b, s)^T \cdot \phi$ is usually simply called *portfolio* or *trading strategy*.

$\begin{pmatrix} B_1 & S_1^u\\ B_1 & S_1^d \end{pmatrix} \cdot \begin{pmatrix} b\\ s \end{pmatrix} = \begin{pmatrix} C_1^u\\ C_1^d \end{pmatrix}$

#+begin_src python
B = (10, np.array((11, 11)))  # price process for the riskless bond
S = (10, np.array((20, 5)))   # price process for the risky stock
M = np.array((B[1], S[1])).T  # matrix with future payoff vectors
K = 15                        # the strike price for the call option
C1 = np.maximum(S[1] - K, 0)  # values for the payoff vector in one year
phi = np.linalg.solve(M, C1)  # find the numerical values of the payoff vector, b and s
#+end_src

** Arbitrage Pricing
